# future

## Poll

Poll是一个`enum`，有两种状态，`Ready`和`Pending`，类似于`Result`。

```rust
pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

`Ready`表示数据已经准备好了，`Pending`表示数据未准备好。

## ready!

类似于`?`，用来判断`Poll`的值，如果是`Pending`就直接返回。

```rust
pub macro ready($e:expr) {
    match $e {
        $crate::task::Poll::Ready(t) => t,
        $crate::task::Poll::Pending => {
            return $crate::task::Poll::Pending;
        }
    }
}

pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {
    let mut fut = future::ready(42);
    let fut = Pin::new(&mut fut);
    // 如果是Pending就直接返回
    let num = ready!(fut.poll(cx));
    // ... use num
    Poll::Ready(())
}
```

## Future

```rust
pub trait Future {
    
    type Output;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

实现Future特征的对象就像一个状态机，如果poll方法返回`Pending`，就等待适合时间再次调用poll方法，直到poll方法返回`Ready`。

## 创建Future

```rust
let go = async {
    let a = 32;
    a
}
```

这样就可以创建一个实现了Future特征的对象。和rust中的其他对象一样，默认**是在栈中申请的**，是值类型。

## async解糖

```rust
let fut_one = /* ... */;
let fut_two = /* ... */;

async move {
    fut_one.await;
    fut_two.await;
}

// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// List of states our `async` block can be in
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = State::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                State::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = State::Done,
                    Poll::Pending => return Poll::Pending,
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}
```



## Future需要满足Send特征

```rust
use std::rc::Rc;

#[derive(Default)]
struct NotSend(Rc<()>);

async fn bar() {}
async fn foo() {
    let x = NotSend::default();
    bar().await;
}

fn require_send(_: impl Send) {}

fn main() {
    require_send(foo());
}
```

这样写没有问题，因为`NotSend::default()`是一个临时变量，并不会保存在Future对象中，如果我们将它保存在一个变量中就会出错。

```rust
use std::rc::Rc;

#[derive(Default)]
struct NotSend(Rc<()>);

async fn bar() {}
async fn foo() {
    let x = NotSend::default();
    bar().await;
}

fn require_send(_: impl Send) {}

fn main() {
    require_send(foo());
}
```

输出结果如下:

```rust
   Compiling playground v0.0.1 (/playground)
warning: unused variable: `x`
 --> src/main.rs:8:9
  |
8 |     let x = NotSend::default();
  |         ^ help: if this is intentional, prefix it with an underscore: `_x`
  |
  = note: `#[warn(unused_variables)]` on by default

error: future cannot be sent between threads safely
  --> src/main.rs:15:18
   |
15 |     require_send(foo());
   |                  ^^^^^ future returned by `foo` is not `Send`
   |
   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`
note: future is not `Send` as this value is used across an await
  --> src/main.rs:9:11
   |
8  |     let x = NotSend::default();
   |         - has type `NotSend` which is not `Send`
9  |     bar().await;
   |           ^^^^^ await occurs here, with `x` maybe used later
note: required by a bound in `require_send`
  --> src/main.rs:12:25
   |
12 | fn require_send(_: impl Send) {}
   |                         ^^^^ required by this bound in `require_send`

warning: `playground` (bin "playground") generated 1 warning
error: could not compile `playground` (bin "playground") due to previous error; 1 warning emitted
```

可见Future是要满足Send特征的，因为Future最终要分配给工作线程去执行，在Future的整个生命周期中，它可能会被不同的线程去执行。

## Unpin

刚才提到Future是要在不同的线程中移动的，但**async创建的future对象**又不满足Unpin特征的，即Future不能随意移动，这不互相矛盾了吗，即要移动，又不能移动。

```rust
use core::future::Future;

fn send<T : Future+Unpin>(m: T) {
}

fn main () {
    let go = async {
        32
    };
    send(go);
}
```



为什么future没有实现Unpin特征，再来看一个例子。



```rust
async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&mut x);
    read_into_buf_fut.await;
    println!("{:?}", x);
}
```

这段代码解糖后可能是

```rust
struct ReadIntoBuf<'a> {
    buf: &'a mut [u8], // points to `x` below
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf<'what_lifetime?>,
}
```

在这里`x`持有`read_into_buf_fut.buf`的引用，如果future对象移动了，那这个引用就是错误的了，它将仍然指向旧的值。有什么办法解决这个问题吗，既能在线程间移动，又不移动future的值，答案就是加一层引用，我们只是在线程间移动future对象的引用。事实上`&mut F`， `Pin`，`Box`也是实现了`Future`特征的。

&mut F，移动的是future的引用。

```rust
impl<F: ?Sized + Future + Unpin> Future for &mut F {
    type Output = F::Output;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        F::poll(Pin::new(&mut **self), cx)
    }
}
```

Pin

```rust
impl<P> Future for Pin<P>
where
    P: ops::DerefMut<Target: Future>,
{
    type Output = <<P as ops::Deref>::Target as Future>::Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        <P::Target as Future>::poll(self.as_deref_mut(), cx)
    }
}
```
Box，将future从栈移动的堆上，在线程间移动的是Box值。
```rust
impl<F: ?Sized + Future + Unpin, A: Allocator> Future for Box<F, A>
where
    A: 'static,
{
    type Output = F::Output;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        F::poll(Pin::new(&mut *self), cx)
    }
}
```



## Pin

pin其实就是解决移动的问题，`pin!`可以创建一个引用，指向栈中的对象。`Box::pin`可以将future移动到堆上。

pin!

```rust
pub macro pin($value:expr $(,)?) {
    $crate::pin::Pin::<&mut _> { pointer: &mut { $value } }
}
```

Box::pin

```rust
pub fn pin(x: T) -> Pin<Box<T>> {
    Box::new(x).into()
}
```

即使我们用了&mut，可以安全的移动future了，但如果我在`mem::swap`呢，一样可以修改&mut指向的值。Pin就是为了解决这个问题的，它将&mut包裹起来了，防止我们修改。一旦对象躲在Pin后面的，我们就不能安全的拿的pointee的&mut引用了。
